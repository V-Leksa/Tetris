<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>–¢–µ—Ç—Ä–∏—Å –Ω–∞ JavaScript</title>
<style>
  body {
    background: black;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    margin: 0;
    color: white;
    font-family: Arial, sans-serif;
  }
  #score {
    margin: 10px;
    font-size: 24px;
  }
  #message {
    margin: 10px;
    font-size: 28px;
    color: red;
    height: 36px; /* –ß—Ç–æ–±—ã –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –æ—Å—Ç–∞–≤–∞–ª–æ—Å—å */
  }
  canvas {
    border: 2px solid white;
  }

  .control-btn {
    width: 70px;             /* —à–∏—Ä–∏–Ω–∞ –∫–Ω–æ–ø–∫–∏ */
    height: 70px;            /* –≤—ã—Å–æ—Ç–∞ –∫–Ω–æ–ø–∫–∏ */
    font-size: 32px;         /* —Ä–∞–∑–º–µ—Ä —Å–∏–º–≤–æ–ª–∞ */
    background-color: #333;  /* —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω */
    color: white;            /* –±–µ–ª—ã–π —Ü–≤–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤ */
    border: none;            /* —É–±–∏—Ä–∞–µ–º —Ä–∞–º–∫—É */
    border-radius: 12px;     /* —Å–∫—Ä—É–≥–ª—ë–Ω–Ω—ã–µ —É–≥–ª—ã */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* —Ç–µ–Ω—å –¥–ª—è –æ–±—ä–µ–º–∞ */
    cursor: pointer;         /* –∫—É—Ä—Å–æ—Ä —É–∫–∞–∑–∞—Ç–µ–ª—å –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
    user-select: none;       /* –∑–∞–ø—Ä–µ—â–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –ø—Ä–∏ —Ç–∞–ø–µ */
    transition: background-color 0.2s ease;
  }
  .control-btn:active, .control-btn:hover {
    background-color: #555;  /* —á—É—Ç—å —Å–≤–µ—Ç–ª–µ–µ –ø—Ä–∏ —Ç–∞–ø–µ –∏–ª–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
  }
</style>
</head>
<body>
  <div id="score">–û—á–∫–∏: 0</div>
  <div id="message"></div>
  <canvas id="game" width="320" height="640"></canvas>

  <!-- –ü–∞–Ω–µ–ª—å —Å–µ–Ω—Å–æ—Ä–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
  <div id="controls" style="margin-top: 10px; display: flex; justify-content: center; gap: 15px;">
  <button id="leftBtn" class="control-btn">‚¨ÖÔ∏è</button>
  <button id="rotateBtn" class="control-btn">üîÑ</button>
  <button id="rightBtn" class="control-btn">‚û°Ô∏è</button>
  <button id="downBtn" class="control-btn">‚¨áÔ∏è</button>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const messageElement = document.getElementById('message');

const grid = 32;
const cols = 10;
const rows = 20;

let playfield = [];
for (let r = 0; r < rows; r++) {
  playfield[r] = new Array(cols).fill(0);
}

const tetrominos = {
  'I': [
    [0,0,0,0],
    [1,1,1,1],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'J': [
    [2,0,0,0],
    [2,2,2,0],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'L': [
    [0,0,3,0],
    [3,3,3,0],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'O': [
    [4,4,0,0],
    [4,4,0,0],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'S': [
    [0,5,5,0],
    [5,5,0,0],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'T': [
    [0,6,0,0],
    [6,6,6,0],
    [0,0,0,0],
    [0,0,0,0]
  ],
  'Z': [
    [7,7,0,0],
    [0,7,7,0],
    [0,0,0,0],
    [0,0,0,0]
  ]
};
const colors = ['cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'];

let currentPiece = null;
let currentX = 0;
let currentY = 0;

let score = 0;
let gameIsOver = false;

function updateScore(points) {
  score += points;
  scoreElement.textContent = '–û—á–∫–∏: ' + score;
}

function spawnPiece() {
  const pieces = Object.keys(tetrominos);
  const rand = pieces[Math.floor(Math.random() * pieces.length)];
  currentPiece = tetrominos[rand];
  currentX = Math.floor(cols / 2) - 2;
  currentY = 0;

  if (collide(currentX, currentY, currentPiece)) {
    gameIsOver = true;
    messageElement.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!';
  }
}

function collide(x, y, piece) {
  for (let r = 0; r < piece.length; r++) {
    for (let c = 0; c < piece[r].length; c++) {
      if (piece[r][c]) {
        let px = x + c;
        let py = y + r;
        if (px < 0 || px >= cols || py >= rows) return true;
        if (py >= 0 && playfield[py][px]) return true;
      }
    }
  }
  return false;
}

function merge(x, y, piece) {
  for (let r = 0; r < piece.length; r++) {
    for (let c = 0; c < piece[r].length; c++) {
      if (piece[r][c] && y + r >= 0) {
        playfield[y + r][x + c] = piece[r][c];
      }
    }
  }
}

function clearLines() {
  let lines = 0;
  for (let r = rows - 1; r >= 0; r--) {
    if (playfield[r].every(cell => cell !== 0)) {
      playfield.splice(r, 1);
      playfield.unshift(new Array(cols).fill(0));
      lines++;
      r++;
    }
  }
  return lines;
}

function rotate(piece) {
  const N = piece.length;
  let newPiece = [];
  for (let x = 0; x < N; x++) {
    newPiece[x] = [];
    for (let y = 0; y < N; y++) {
      newPiece[x][y] = piece[N - y - 1][x] || 0;
    }
  }
  return newPiece;
}

function drawCell(x, y, colorIndex) {
  ctx.fillStyle = colors[colorIndex - 1];
  ctx.fillRect(x * grid, y * grid, grid - 1, grid - 1);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (playfield[r][c]) {
        drawCell(c, r, playfield[r][c]);
      }
    }
  }
  if (currentPiece) {
    for (let r = 0; r < currentPiece.length; r++) {
      for (let c = 0; c < currentPiece[r].length; c++) {
        if (currentPiece[r][c]) {
          drawCell(currentX + c, currentY + r, currentPiece[r][c]);
        }
      }
    }
  }
}

function drop() {
  if (gameIsOver) return;
  if (!collide(currentX, currentY + 1, currentPiece)) {
    currentY++;
  } else {
    merge(currentX, currentY, currentPiece);
    let lines = clearLines();
    if (lines > 0) {
      updateScore(lines * 10);
    }
    spawnPiece();
  }
}

function moveLeft() {
  if (gameIsOver) return;
  if (!collide(currentX - 1, currentY, currentPiece)) {
    currentX--;
  }
}

function moveRight() {
  if (gameIsOver) return;
  if (!collide(currentX + 1, currentY, currentPiece)) {
    currentX++;
  }
}

function rotatePiece() {
  if (gameIsOver) return;
  let rotated = rotate(currentPiece);
  if (!collide(currentX, currentY, rotated)) {
    currentPiece = rotated;
  }
}

spawnPiece();
draw();

let dropInterval = 500;
let lastTime = 0;

function loop(time = 0) {
  if (gameIsOver) return;
  const delta = time - lastTime;
  if (delta > dropInterval) {
    drop();
    lastTime = time;
    draw();
  }
  requestAnimationFrame(loop);
}

document.addEventListener('keydown', event => {
  if (gameIsOver) return;
  if (event.key === 'ArrowLeft') {
    moveLeft();
    draw();
  } else if (event.key === 'ArrowRight') {
    moveRight();
    draw();
  } else if (event.key === 'ArrowDown') {
    drop();
    draw();
  } else if (event.key === 'ArrowUp') {
    rotatePiece();
    draw();
  }
});

loop();

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Å–µ–Ω—Å–æ—Ä–Ω—ã—Ö –∫–Ω–æ–ø–æ–∫
  document.getElementById('leftBtn').addEventListener('touchstart', () => {
    moveLeft();
    draw();
  });
  document.getElementById('rightBtn').addEventListener('touchstart', () => {
    moveRight();
    draw();
  });
  document.getElementById('downBtn').addEventListener('touchstart', () => {
    drop();
    draw();
  });
  document.getElementById('rotateBtn').addEventListener('touchstart', () => {
    rotatePiece();
    draw();
  });

  // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ click –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–∞
  document.getElementById('leftBtn').addEventListener('click', () => {
    moveLeft();
    draw();
  });
  document.getElementById('rightBtn').addEventListener('click', () => {
    moveRight();
    draw();
  });
  document.getElementById('downBtn').addEventListener('click', () => {
    drop();
    draw();
  });
  document.getElementById('rotateBtn').addEventListener('click', () => {
    rotatePiece();
    draw();
  });
</script>
</body>
</html>
